<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Activity启动模式 · Lis</title><meta name="description" content="Activity启动模式 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/2018.jpg"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="Lis"><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Lis" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">Lis</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><ul class="shortcut-icons"><a href="https://github.com/xunyixiangchao" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">Activity启动模式</h1><div class="post-info">2020年12月11日</div><div class="post-content"><h1><span id="从四个视角理解android-activity启动模式">从四个视角理解Android Activity启动模式</span></h1><p>系统视角：</p>
<h2><span id="1-android的软件体系结构">1. Android的软件体系结构</span></h2><p><img src="/2020/12/11/activity/%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="系统结构图"></p>
<h2><span id="12-task">1.2 Task</span></h2><p><img src="/2020/12/11/activity/task.png" alt="Task"></p>
<p>Activity代码属于Application，但是Task属于Android操作系统</p>
<p>Task是可以跨应用的</p>
<h3><span id="手机查看task用户角度">手机查看Task：（用户角度）</span></h3><p>手机中按home键旁边那个方形键（recent-apps）时，屏幕上展示的就是一个个task。</p>
<p><img src="/2020/12/11/activity/%E6%9F%A5%E7%9C%8BTask.png" alt="查看手机Task"></p>
<h3><span id="代码中查看task程序角度">代码中查看Task：（程序角度）</span></h3><p>adb shell dumpsys activity activities | sed -En -e ‘/Stack #/p’ -e ‘/Running activities/,/Run #0/p’</p>
<p>sed工具不用单独下载，<code>D:\soft\Git\usr\bin\sed.exe</code> Git安装目录下包含，配置下环境变量就可以。 </p>
<p>用户视角：</p>
<h2><span id="21-task启动方式launcher启动">2.1 Task启动方式(launcher启动)</span></h2><p>Launcher启动</p>
<p>1、Task不存在</p>
<p>2、Task存在</p>
<h2><span id="22-task启动方式新建">2.2 Task启动方式（新建）</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">intent.putExtra(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;message&quot;</span>);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>通知：</p>
<p>1.系统通知<br>2.自己</p>
<p>其他第三方应用：</p>
<p>1、Scheme协议<br>2、第三方应用start</p>
<p><strong>launcher,新建  都是通过startActivity来创建的。</strong></p>
<h2><span id="23-task启动方式恢复">2.3 Task启动方式（恢复）</span></h2><p><strong>恢复</strong>   这属于Activity生命周期由不可见到获得焦点的范畴</p>
<p><img src="/2020/12/11/activity/Task%E6%81%A2%E5%A4%8D.png" alt="Task恢复"></p>
<p>程序视角：</p>
<h2><span id="31-activity和fragment">3.1 Activity和Fragment</span></h2><p>Fragment是Android3.0后引入的一个新的API，他出现的初衷是为了适应大屏幕的平板电脑， 当然现在他仍然是平板APP UI设计的宠儿，而且我们普通手机开发也会加入这个Fragment， 我们可以把他看成一个小型的Activity，又称Activity片段！</p>
<p><img src="/2020/12/11/activity/fragment%E9%9D%99%E6%80%81%E5%8A%A0%E8%BD%BD.png" alt="fragment静态加载"></p>
<p><img src="/2020/12/11/activity/fragment%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD.png" alt="fragment动态载"></p>
<h2><span id="32-activity的生命周期">3.2 Activity的生命周期</span></h2><p><img src="/2020/12/11/activity/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Activity生命周期"></p>
<p>Activity是否可见：</p>
<p><img src="/2020/12/11/activity/Activity%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A7%81.png" alt="Activity是否可见"></p>
<p>PS:Fragment生命周期</p>
<p><img src="/2020/12/11/activity/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.webp" alt="fragment生命周期"></p>
<p>Activity与Fragment生命周期</p>
<p><img src="/2020/12/11/activity/activity%E4%B8%8Efragment.png" alt="Activity与Fragment生命周期"></p>
<h2><span id="33-相邻状态之间的区别">3.3 相邻状态之间的区别</span></h2><p><img src="/2020/12/11/activity/%E7%9B%B8%E9%82%BB%E7%8A%B6%E6%80%81%E5%8C%BA%E5%88%AB.png" alt="A启动B和B返回A"></p>
<p>A启动B    和    B返回A</p>
<p><strong>1.onCreate</strong>和<strong>onStart</strong>之间有什么区别？</p>
<p>（1）可见与不可见的区别。前者不可见，后者可见。<br>（2）执行次数的区别。onCreate方法只在Activity创建时执行一次，而onStart方法在Activity的切换以及按Home键返回桌面再切回应用的过程中被多次调用。因此Bundle数据的恢复在onStart中进行比onCreate中执行更合适。<br> （3）onCreate能做的事onStart其实都能做，但是onstart能做的事onCreate却未必适合做。如前文所说的，setContentView和资源初始化在两者都能做，然而想动画的初始化在onStart中做比较好。</p>
<p><strong>2.onStart</strong>方法和<strong>onResume</strong>方法有什么区别？</p>
<p>（1）是否在前台。onStart方法中Activity可见但不在前台，不可交互，而在onResume中在前台。<br>（2）职责不同，onStart方法中主要还是进行初始化工作，而onResume方法，根据官方的建议，可以做开启动画和独占设备的操作。</p>
<p><strong>3.onPause</strong>方法和<strong>onStop</strong>方法有什么区别？</p>
<p>（1）是否可见。onPause时Activity可见，onStop时Activity不可见，但Activity对象还在内存中。<br>（2）在系统内存不足的时候可能不会执行onStop方法，因此程序状态的保存、独占设备和动画的关闭、以及一些数据的保存最好在onPause中进行，但要注意不能太耗时。</p>
<p><strong>4.onStop</strong>方法和<strong>onDestroy</strong>方法有什么区别？</p>
<p>onStop阶段Activity还没有被销毁，对象还在内存中，此时可以通过切换Activity再次回到该Activity，而onDestroy阶段Acivity被销毁</p>
<p>**PS:**闪屏页：在onStop()方法中进行finish();</p>
<h2><span id="34-onnewintent的生命周期">3.4 onNewIntent的生命周期</span></h2><p><img src="/2020/12/11/activity/onNewIntent.png" alt="onNewIntent"></p>
<p>1、只对<strong>singleTop，singleTask，singleInstance</strong>有效，因为standard每次都是新建(不是绝对，使用了Intent.FLAG_ACTIVITY_NEW_TASK,要启动的Activity已经有Task在运行了，新的activity不会再创建，而是把当前堆栈的activity带到前台)，所以不存在onNewIntent；</p>
<p>2、只对startActivity有效，对于从Navigation切换回来的恢复无效；</p>
<h2><span id="41-activity启动模式">4.1 Activity启动模式</span></h2><p><img src="/2020/12/11/activity/%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.png" alt="四种启动模式"></p>
<h2><span id="42-standard启动模式">4.2 standard启动模式</span></h2><p><strong>1、standard</strong>  <strong>默认模式</strong></p>
<p>系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，不管这个实例是否已经存在，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。这种模式的 Activity 被创建时它的 onCreate、onStart 都会被调用。这是一种典型的多实例实现，一个任务栈中可以有多个实例，每个实例也可以属于不同的任务栈。在这种模式下，谁启动了这个 Activity，那么这个 Activity 就运行在启动它的那个 Activity 所在的栈中。</p>
<p>a、当从非Activity的context启动activity时，需要带new_task的flag；</p>
<p>b、当启动一个带有affinity的activity，如果这个activity已经有实例存在该task，则不会重新创建；</p>
<p>c、如果从应用内启动的standard activity的Affinity就是App默认的Affinity，则会每次新建一个实例；</p>
<h2><span id="43-singletop启动模式">4.3 singleTop启动模式</span></h2><p>一个singleTop Activity 的实例可以无限多，唯一的区别是如果在栈顶已经有一个相同类型的Activity实例，Intent不会再创建一个Activity，而是通过onNewIntent()被发送到现有的Activity。</p>
<p><img src="/2020/12/11/activity/singetop.png" alt="singleTop"></p>
<h2><span id="44-singletask模式">4.4 singleTask模式</span></h2><p>这是一种单实例模式，在这种模式下，只要 Activity 在一个栈中存在，那么多次启动此 Activity 都不会重新创建实例，和 singleTop一样，系统也会回调其 onNewIntent。当一个具有 singleTask 模式的Activity请求启动后，比如 Activity A，系统首先会寻找是否存在 A 想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建 A 的实例后把 A 放到栈中。如果存在 A 所需的任务栈，这时要看 A 是否在栈中有实例存在，如果有实例存在，那么系统就会把 A 调到栈顶并调用它的 onNewIntent 方法，如果实例不存在，就创建 A 的实例并把 A 压入栈中 。</p>
<p><img src="/2020/12/11/activity/singleTask.png" alt="singleTask"></p>
<p>不需要关注NEW_TASK</p>
<h2><span id="45-singleinstance模式">4.5 singleInstance模式</span></h2><p>与 singleTask 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。也就是有此种模式的 Activity 只能单独地位于一个任务栈中</p>
<p>PS：4种模式只能在AndroidManifest.xml中定义（定义层定义的）</p>
<h2><span id="46-intent-activity-flag">4.6 Intent Activity Flag</span></h2><p>启动层定义</p>
<p><img src="/2020/12/11/activity/IntentFlag.png" alt="IntentFlag"></p>
<h2><span id="51-启动模式的应用场景">5.1 启动模式的应用场景</span></h2><table>
<thead>
<tr>
<th><strong>launchMode</strong></th>
<th><strong>使用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>singleTop</td>
<td>适合启动同类型的   Activity，例如：   •接收通知启动的内容显示页面   •耗时操作返回页面   •登录页面</td>
</tr>
<tr>
<td>singleTask</td>
<td>适合作为程序入口，例如：   •WebView页面   •扫一扫页面   •确认订单界面   •付款界面</td>
</tr>
<tr>
<td>singleInstance</td>
<td>适合需要与程序分离开的页面，例如：   •闹铃的响铃界面   •来电页面   •锁屏页</td>
</tr>
</tbody></table>
</div></article></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'lis';
var disqus_identifier = '2020/12/11/activity/';
var disqus_title = 'Activity启动模式';
var disqus_url = 'http://example.com/2020/12/11/activity/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//lis.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/2020/12/10/okhttp/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2021 <a href="http://example.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"lis",'auto');ga('send','pageview');</script></body></html>